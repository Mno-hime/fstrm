<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fstrm: Library overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fstrm
   &#160;<span id="projectnumber">0.4.0</span>
   </div>
   <div id="projectbrief">Frame Streams implementation in C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('overview.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Library overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="init"></a>
Initializing the library</h1>
<p><code>fstrm</code> has no global library state. In most cases, only a single <a class="el" href="group__fstrm__iothr.html">fstrm_iothr</a> library context object will be needed for the entire process, which will implicitly create a background I/O serialization thread. This I/O thread is bound to a particular output writer (for example, an <code>AF_UNIX</code> socket) and is fully buffered &ndash; submitted data frames will be accumulated in an output buffer and periodically flushed, minimizing the number of system calls that need to be performed. This frees worker threads from waiting for a write() to complete.</p>
<p><code>fstrm</code> abstracts the actual I/O operations needed to read or write a byte stream. File and socket I/O implementations are included in the library, but if necessary <code>fstrm</code> can be extended to support new types of byte stream transports. See the <a class="el" href="group__fstrm__reader.html">fstrm_reader</a>, <a class="el" href="group__fstrm__writer.html">fstrm_writer</a>, and <a class="el" href="group__fstrm__rdwr.html">fstrm_rdwr</a> interfaces for details.</p>
<p>The following code example shows the initialization of an <code>fstrm_iothr</code> library context object connected to an <a class="el" href="group__fstrm__file.html">fstrm_file</a> writer. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *file_path = <span class="stringliteral">&quot;/tmp/output.fs&quot;</span>;</div><div class="line"><span class="keyword">struct </span>fstrm_file_options *fopt;</div><div class="line"><span class="keyword">struct </span>fstrm_iothr *iothr;</div><div class="line"><span class="keyword">struct </span>fstrm_writer *writer;</div><div class="line"></div><div class="line">fopt = <a class="code" href="group__fstrm__file.html#gaef21defcea243f0b02124ea7ec097bce" title="Initialize an fstrm_file_options object, which is needed to configure the file path to be opened by f...">fstrm_file_options_init</a>();</div><div class="line"><a class="code" href="group__fstrm__file.html#ga32e7b8761e690634d086a97301884781" title="Set the file_path option. ">fstrm_file_options_set_file_path</a>(fopt, file_path);</div><div class="line"></div><div class="line">writer = <a class="code" href="group__fstrm__file.html#ga0996800d71c6be618760328383be785e" title="Open a file for writing Frame Streams data. ">fstrm_file_writer_init</a>(fopt, NULL);</div><div class="line"><span class="keywordflow">if</span> (!writer) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Error: fstrm_file_writer_init() failed.\n&quot;</span>);</div><div class="line">        exit(EXIT_FAILURE);</div><div class="line">}</div><div class="line"></div><div class="line">iothr = <a class="code" href="group__fstrm__iothr.html#gaaff915df783dcf02866ea8b41e54d701" title="Initialize an fstrm_iothr object. ">fstrm_iothr_init</a>(NULL, &amp;writer);</div><div class="line"><span class="keywordflow">if</span> (!iothr) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Error: fstrm_iothr_init() failed.\n&quot;</span>);</div><div class="line">        exit(EXIT_FAILURE);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group__fstrm__file.html#ga3b2760be9820766eb1d3a8b856ff373f" title="Destroy an fstrm_file_options object. ">fstrm_file_options_destroy</a>(&amp;fopt);</div></div><!-- fragment --><p>Since the I/O operations are abstracted through the <code>fstrm_writer</code> interface, the <code>writer</code> variable in the above example could instead have been initialized with a completely different implementation. For example, <a class="el" href="group__fstrm__unix__writer.html">fstrm_unix_writer</a> objects can be initialized as follows: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *socket_path = <span class="stringliteral">&quot;/tmp/output.sock&quot;</span>;</div><div class="line"><span class="keyword">struct </span>fstrm_writer *writer;</div><div class="line"><span class="keyword">struct </span>fstrm_unix_writer_options *uwopt;</div><div class="line"></div><div class="line">uwopt = <a class="code" href="group__fstrm__unix__writer.html#gae4750b1f83eab7ac764b8997835fbaec" title="Initialize an fstrm_unix_writer_options object, which is needed to configure the socket path to be op...">fstrm_unix_writer_options_init</a>();</div><div class="line"><a class="code" href="group__fstrm__unix__writer.html#gaa46408d124da9ac3af053cb00d8b688a" title="Set the socket_path option. ">fstrm_unix_writer_options_set_socket_path</a>(uwopt, socket_path);</div><div class="line"></div><div class="line">writer = <a class="code" href="group__fstrm__unix__writer.html#gaad9a7cbbc6ac5a50997cfba4a4fd8bba" title="Initialize the fstrm_writer object. ">fstrm_unix_writer_init</a>(uwopt, NULL);</div><div class="line"><span class="keywordflow">if</span> (!writer) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Error: fstrm_unix_writer_init() failed.\n&quot;</span>);</div><div class="line">        exit(EXIT_FAILURE);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="queue"></a>
Getting an input queue</h1>
<p>After the <code>fstrm_iothr</code> object has been created with <a class="el" href="group__fstrm__iothr.html#gaaff915df783dcf02866ea8b41e54d701" title="Initialize an fstrm_iothr object. ">fstrm_iothr_init()</a>, an input queue handle can be obtained with the <a class="el" href="group__fstrm__iothr.html#ga18eebf6363c1d1f0f3d7b7428bf21d32" title="Obtain an fstrm_iothr_queue object for submitting data frames to the fstrm_iothr object. ">fstrm_iothr_get_input_queue()</a> function, which returns an <code>fstrm_iothr_queue</code> object. This function is thread-safe and returns a unique queue each time it is called, up to the number of queues specified by <a class="el" href="group__fstrm__iothr.html#ga2908d79bee85349210ac000765a4c8e2" title="Set the num_input_queues parameter. ">fstrm_iothr_options_set_num_input_queues()</a>. <code>fstrm_iothr_queue</code> objects belong to their parent <code>fstrm_iothr</code> object and will be destroyed when the parent <code>fstrm_iothr</code> object is destroyed.</p>
<p>The following code example shows a single <code>fstrm_iothr_queue</code> handle being obtained from an already initialized <code>fstrm_iothr</code> library context object. </p><div class="fragment"><div class="line"><span class="comment">// &#39;iothr&#39; is a struct fstrm_iothr *</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>fstrm_iothr_queue *ioq;</div><div class="line">ioq = <a class="code" href="group__fstrm__iothr.html#ga18eebf6363c1d1f0f3d7b7428bf21d32" title="Obtain an fstrm_iothr_queue object for submitting data frames to the fstrm_iothr object. ">fstrm_iothr_get_input_queue</a>(iothr);</div><div class="line"><span class="keywordflow">if</span> (!ioq) {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Error: fstrm_iothr_get_input_queue() failed.\n&quot;</span>);</div><div class="line">        exit(EXIT_FAILURE);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="submit"></a>
Submitting data frames</h1>
<p>Once the <code>fstrm_iothr</code> object has been created and an <code>fstrm_iothr_queue</code> handle is available, data frames can be submitted for asynchronous writing using the <a class="el" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit()</a> function. A callback is passed to this function which will be invoked to deallocate the data frame once the I/O thread has completed processing it. In the common case where the data frame is dynamically allocated with <code>malloc()</code>, the deallocation callback must call <code>free()</code>. <a class="el" href="group__fstrm__iothr.html#ga34e96f0ef194f71d68b6354743128a74" title="Wrapper function for the system&#39;s free(), suitable for use as the free_func callback for fstrm_iothr_...">fstrm_free_wrapper()</a> is provided as a convenience function which does this and can be specified as the <code>free_func</code> parameter to <a class="el" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit()</a>.</p>
<p>If space is available in the queue, <a class="el" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit()</a> will return <a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a>, indicating that ownership of the memory allocation for the data frame has passed from the caller to the library. The caller must not reuse or deallocate the memory for the data frame after a successful call to <a class="el" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit()</a>.</p>
<p>Callers must check the return value of <a class="el" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit()</a>. If this function fails, that is, it returns any result code other than <a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a>, the caller must deallocate or otherwise dispose of memory allocated for the data frame, in order to avoid leaking memory. <a class="el" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit()</a> can fail with <a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ae906277e8e9b1fbd343edbcabbe42c8b" title="Resource temporarily unavailable. ">fstrm_res_again</a> if there is currently no space in the circular queue for an additional frame, in which case a later call to <a class="el" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit()</a> with the same parameters may succeed. However, if <a class="el" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit()</a> fails with <a class="el" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329aa07e4708dcaecdf72b937ab52841c69a" title="Parameters were invalid. ">fstrm_res_invalid</a>, then there is a problem with the parameters and a later call will not succeed.</p>
<p>The following code example shows data frames containing a short sequence of bytes being created and submitted repeatedly, with appropriate error handling. Note that the data frames in this example intentionally contain embedded unprintable characters, showing that Frame Streams is binary clean. This example follows from the previous examples, where the <code>iothr</code> and <code>ioq</code> variables have already been initialized. </p><div class="fragment"><div class="line"><span class="comment">// &#39;iothr&#39; is a struct fstrm_iothr *</span></div><div class="line"><span class="comment">// &#39;ioq&#39; is a struct fstrm_queue *</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> num_frames = 100;</div><div class="line"><span class="keyword">const</span> uint8_t frame_template[] = {</div><div class="line">        <span class="charliteral">&#39;H&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, 0x00, 0x01, 0x02, 0x03,</div><div class="line">        <span class="charliteral">&#39;W&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, 0x04, 0x05, 0x06, 0x07,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_frames; i++) {</div><div class="line">        <span class="comment">// Allocate a new frame from the template.</span></div><div class="line">        uint8_t *frame = malloc(<span class="keyword">sizeof</span>(frame_template));</div><div class="line">        <span class="keywordflow">if</span> (!frame)</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">        memcpy(frame, frame_template, <span class="keyword">sizeof</span>(frame_template));</div><div class="line"></div><div class="line">        <span class="comment">// Submit the frame for writing.</span></div><div class="line">        <span class="keywordflow">for</span> (;;) {</div><div class="line">                <a class="code" href="group__fstrm__res.html#gad3cb32b083ff99d02ccfbc1a69823329" title="Result codes for functions. ">fstrm_res</a> res;</div><div class="line">                res = <a class="code" href="group__fstrm__iothr.html#ga1c00c9adb179885e7cf2dc05e940f67d" title="Submit a data frame to the background I/O thread. ">fstrm_iothr_submit</a>(iothr, ioq, frame,</div><div class="line">                                         <span class="keyword">sizeof</span>(frame_template),</div><div class="line">                                         <a class="code" href="group__fstrm__iothr.html#ga34e96f0ef194f71d68b6354743128a74" title="Wrapper function for the system&#39;s free(), suitable for use as the free_func callback for fstrm_iothr_...">fstrm_free_wrapper</a>, NULL);</div><div class="line">                <span class="keywordflow">if</span> (res == <a class="code" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329a89de17ab416590c6c61b2b5f7dd7844a" title="Success. ">fstrm_res_success</a>) {</div><div class="line">                        <span class="comment">// Frame successfully queued.</span></div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (res == <a class="code" href="group__fstrm__res.html#ggad3cb32b083ff99d02ccfbc1a69823329ae906277e8e9b1fbd343edbcabbe42c8b" title="Resource temporarily unavailable. ">fstrm_res_again</a>) {</div><div class="line">                        <span class="comment">// Queue is full. Try again in a busy loop.</span></div><div class="line">                        <span class="comment">// Alternatively, if loss can be tolerated we</span></div><div class="line">                        <span class="comment">// could free the frame here and break out of</span></div><div class="line">                        <span class="comment">// the loop.</span></div><div class="line">                        <span class="keywordflow">continue</span>;</div><div class="line">                } <span class="keywordflow">else</span> {</div><div class="line">                        <span class="comment">// Permanent failure.</span></div><div class="line">                        free(frame);</div><div class="line">                        fputs(<span class="stringliteral">&quot;fstrm_iothr_submit() failed.\n&quot;</span>, stderr);</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="shutdown"></a>
Shutting down</h1>
<p>Calling <a class="el" href="group__fstrm__iothr.html#ga464c4256012684ec71653fb52624870d" title="Destroy an fstrm_iothr object. ">fstrm_iothr_destroy()</a> on the <code>fstrm_iothr</code> object will signal the I/O thread to flush any outstanding data frames being written and will deallocate all associated resources. This function is synchronous and does not return until the I/O thread has terminated. </p><div class="fragment"><div class="line"><span class="comment">// &#39;iothr&#39; is a struct fstrm_iothr *</span></div><div class="line"><a class="code" href="group__fstrm__iothr.html#ga464c4256012684ec71653fb52624870d" title="Destroy an fstrm_iothr object. ">fstrm_iothr_destroy</a>(&amp;iothr);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
